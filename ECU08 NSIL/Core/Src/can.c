#include "can.h"
#include <string.h>

/* These handles must exist in your project (generated by CubeMX). */
extern FDCAN_HandleTypeDef hfdcan1;
extern FDCAN_HandleTypeDef hfdcan2;
extern FDCAN_HandleTypeDef hfdcan3;

/* ==== Project CAN IDs (from your VCU header; keep as defines) ==== */
#define ID_ACK_PRECARGA        0x20u
#define ID_DC_BUS_VOLTAGE      0x100u
#define ID_S1_ACELERACION      0x101u
#define ID_S2_ACELERACION      0x102u
#define ID_S_FRENO             0x103u
#define ID_V_CELDA_MIN         0x12Cu

#define TX_STATE_2             0x461u
#define TX_STATE_4             0x463u
#define TX_STATE_5             0x464u
#define TX_STATE_6             0x465u
#define TX_STATE_7             0x466u

/* Optional inverter command IDs (from vcu.txt). Adjust as needed. */
#define TXID_INVERSOR          0x181u
#define RXID_INVERSOR          0x201u

/* Packing layout:
 * w0 = id
 * w1 = (dlc) | (bus<<8) | (ide<<16)
 * w2 = data[0..3] packed little-endian
 * w3 = data[4..7] packed little-endian
 */
static uint32_t pack_u32_le(const uint8_t b[4])
{
  return ((uint32_t)b[0]) | ((uint32_t)b[1] << 8) | ((uint32_t)b[2] << 16) | ((uint32_t)b[3] << 24);
}
static void unpack_u32_le(uint32_t w, uint8_t b[4])
{
  b[0] = (uint8_t)(w & 0xFFu);
  b[1] = (uint8_t)((w >> 8) & 0xFFu);
  b[2] = (uint8_t)((w >> 16) & 0xFFu);
  b[3] = (uint8_t)((w >> 24) & 0xFFu);
}

void CAN_Pack16(const can_msg_t *m, can_qitem16_t *q)
{
  if (!m || !q) return;
  q->w[0] = m->id;
  q->w[1] = ((uint32_t)(m->dlc & 0xFu)) | (((uint32_t)m->bus & 0xFFu) << 8) | (((uint32_t)m->ide & 0x1u) << 16);
  q->w[2] = pack_u32_le(&m->data[0]);
  q->w[3] = pack_u32_le(&m->data[4]);
}

void CAN_Unpack16(const can_qitem16_t *q, can_msg_t *m)
{
  if (!m || !q) return;
  memset(m, 0, sizeof(*m));
  m->id  = q->w[0];
  m->dlc = (uint8_t)(q->w[1] & 0xFu);
  m->bus = (can_bus_t)((q->w[1] >> 8) & 0xFFu);
  m->ide = (uint8_t)((q->w[1] >> 16) & 0x1u);
  unpack_u32_le(q->w[2], &m->data[0]);
  unpack_u32_le(q->w[3], &m->data[4]);
}

/* === RX parser: move your ISR switch() here === */
void CanRx_ParseAndUpdate(const can_msg_t *m, app_inputs_t *st)
{
  if (!m || !st) return;

  switch (m->id)
  {
    case ID_ACK_PRECARGA:
      st->ok_precarga = m->data[0];
      break;

    case ID_DC_BUS_VOLTAGE:
      /* Example: voltage in first two bytes (little endian). Adjust to your real format. */
      st->inv_dc_bus_voltage = (uint16_t)((uint16_t)m->data[0] | ((uint16_t)m->data[1] << 8));
      break;

    case ID_S1_ACELERACION:
      st->s1_aceleracion = (uint16_t)((uint16_t)m->data[0] | ((uint16_t)m->data[1] << 8));
      break;

    case ID_S2_ACELERACION:
      st->s2_aceleracion = (uint16_t)((uint16_t)m->data[0] | ((uint16_t)m->data[1] << 8));
      break;

    case ID_S_FRENO:
      st->s_freno = (uint16_t)((uint16_t)m->data[0] | ((uint16_t)m->data[1] << 8));
      break;

    case ID_V_CELDA_MIN:
      st->v_celda_min = (uint16_t)((uint16_t)m->data[0] | ((uint16_t)m->data[1] << 8));
      break;

    case TX_STATE_2:
    case TX_STATE_4:
    case TX_STATE_5:
    case TX_STATE_6:
    case TX_STATE_7:
      /* Example: state in byte0. Adjust to your real mapping. */
      st->inv_state = m->data[0];
      break;

    default:
      /* TODO: add remaining IDs from your current callback */
      break;
  }
}

/* === Central TX === */
static FDCAN_HandleTypeDef* bus_to_hfdcan(can_bus_t bus)
{
  switch (bus)
  {
    case CAN_BUS_INV:  return &hfdcan1;
    case CAN_BUS_ACU:  return &hfdcan2;
    case CAN_BUS_DASH: return &hfdcan3;
    default:           return &hfdcan1;
  }
}

HAL_StatusTypeDef CanTx_SendHal(const can_msg_t *m)
{
  if (!m) return HAL_ERROR;

  FDCAN_TxHeaderTypeDef txh;
  memset(&txh, 0, sizeof(txh));

  txh.Identifier = m->id;
  txh.IdType     = (m->ide ? FDCAN_EXTENDED_ID : FDCAN_STANDARD_ID);
  txh.TxFrameType= FDCAN_DATA_FRAME;
  txh.DataLength = (m->dlc <= 8) ? ((uint32_t)m->dlc << 16) : FDCAN_DLC_BYTES_8; /* Cube HAL expects DLC enum; adjust if needed */
  txh.ErrorStateIndicator = FDCAN_ESI_ACTIVE;
  txh.BitRateSwitch       = FDCAN_BRS_OFF;
  txh.FDFormat            = FDCAN_CLASSIC_CAN;
  txh.TxEventFifoControl  = FDCAN_NO_TX_EVENTS;
  txh.MessageMarker       = 0;

  /* NOTE: Some Cube HALs require DataLength to be one of FDCAN_DLC_BYTES_x.
   * If your HAL complains, replace the DataLength assignment with a small mapping table.
   */

  return HAL_FDCAN_AddMessageToTxFifoQ(bus_to_hfdcan(m->bus), &txh, (uint8_t*)m->data);
}

/* === ISR helper === */
void Can_ISR_PushRxFifo0(FDCAN_HandleTypeDef *hfdcan)
{
  if (!hfdcan || !canRxQueueHandle) return;

  FDCAN_RxHeaderTypeDef rxh;
  uint8_t data[8];
  if (HAL_FDCAN_GetRxMessage(hfdcan, FDCAN_RX_FIFO0, &rxh, data) != HAL_OK) return;

  can_msg_t m;
  memset(&m, 0, sizeof(m));

  if (hfdcan == &hfdcan1) m.bus = CAN_BUS_INV;
  else if (hfdcan == &hfdcan2) m.bus = CAN_BUS_ACU;
  else if (hfdcan == &hfdcan3) m.bus = CAN_BUS_DASH;
  else m.bus = CAN_BUS_INV;

  m.id  = rxh.Identifier;
  m.ide = (rxh.IdType == FDCAN_EXTENDED_ID) ? 1u : 0u;

  /* DLC extraction varies by HAL; this is a common pattern for classic CAN <=8 bytes. */
  switch (rxh.DataLength)
  {
    case FDCAN_DLC_BYTES_0: m.dlc = 0; break;
    case FDCAN_DLC_BYTES_1: m.dlc = 1; break;
    case FDCAN_DLC_BYTES_2: m.dlc = 2; break;
    case FDCAN_DLC_BYTES_3: m.dlc = 3; break;
    case FDCAN_DLC_BYTES_4: m.dlc = 4; break;
    case FDCAN_DLC_BYTES_5: m.dlc = 5; break;
    case FDCAN_DLC_BYTES_6: m.dlc = 6; break;
    case FDCAN_DLC_BYTES_7: m.dlc = 7; break;
    case FDCAN_DLC_BYTES_8: m.dlc = 8; break;
    default: m.dlc = 8; break;
  }

  memcpy(m.data, data, 8);

  can_qitem16_t q;
  CAN_Pack16(&m, &q);

  (void)osMessageQueuePut(canRxQueueHandle, &q, 0, 0);
}
