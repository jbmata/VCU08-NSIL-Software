/* app_tasks.c - CMSIS-RTOS v2 tasks (6 tasks) */

#include "app_tasks.h"

#include "cmsis_os2.h"
#include <string.h>
#include <stdio.h>

/* Project modules (flat structure) */
#include "app_state.h"
#include "can.h"
#include "control.h"
#include "telemetry.h"
#include "diag.h"
#include "FreeRTOS.h"
#include "task.h"


/* These are created in freertos.c (CubeMX) */
extern osMessageQueueId_t canRxQueueHandle;
extern osMessageQueueId_t canTxQueueHandle;

/* -------------------- helpers -------------------- */

static uint32_t ms_to_ticks(uint32_t ms)
{
  /* CMSIS-RTOS v2 tick frequency: ticks per second */
  const uint32_t f = osKernelGetTickFreq();
  /* Round up to avoid 0-tick periods */
  return (ms * f + 999U) / 1000U;
}

/* -------------------- Task: App_InitTask -------------------- */

void App_InitTask(void *argument)
{
  (void)argument;

  /* Initialize shared state */
  AppState_Init();

  /* Optional: initial diag line */
  Diag_Log("App_InitTask: init done\r\n");

  /* Usually we can exit this init task */
  osThreadExit();

  /* If you prefer to keep it alive, replace osThreadExit() with:
     for(;;) { osDelay(1000); }
  */
}

/* -------------------- Task: CanRxTask -------------------- */

void CanRxTask(void *argument)
{
  (void)argument;

  can_qitem16_t qi;
  can_msg_t msg;

  for (;;)
  {
    /* Block indefinitely waiting for RX items */
    if (osMessageQueueGet(canRxQueueHandle, &qi, NULL, osWaitForever) == osOK)
    {
      CAN_Unpack16(&qi, &msg);

      /* Update shared state under mutex */
      osMutexAcquire(g_inMutex, osWaitForever);
      CanRx_ParseAndUpdate(&msg, &g_in);
      osMutexRelease(g_inMutex);
    }
  }
}

/* -------------------- Task: CanTxTask -------------------- */

void CanTxTask(void *argument)
{
  (void)argument;

  can_qitem16_t qi;
  can_msg_t msg;

  for (;;)
  {
    /* Block indefinitely waiting for TX items */
    if (osMessageQueueGet(canTxQueueHandle, &qi, NULL, osWaitForever) == osOK)
    {
      CAN_Unpack16(&qi, &msg);

      /* Single point of HAL TX */
      (void)CanTx_SendHal(&msg);
    }
  }
}

/* -------------------- Task: ControlTask (10 ms) -------------------- */

void ControlTask(void *argument)
{
  (void)argument;

  const uint32_t period = ms_to_ticks(10);
  uint32_t next = osKernelGetTickCount();

  /* Local copies to minimize mutex holding time */
  app_inputs_t in_snap;
  control_out_t out;

  for (;;)
  {
    next += period;
    osDelayUntil(next);

    /* Snapshot inputs/state */
    osMutexAcquire(g_inMutex, osWaitForever);
    in_snap = g_in; /* structure copy */
    osMutexRelease(g_inMutex);

    /* Compute control step (pure logic) */
    Control_Step10ms(&in_snap, &out);

    /* Enqueue any CAN frames generated by control */
    for (uint32_t i = 0; i < out.count; i++)
    {
      can_qitem16_t qout;
      CAN_Pack16(&out.msgs[i], &qout);
      (void)osMessageQueuePut(canTxQueueHandle, &qout, 0U, 0U);
    }

  }
}

/* -------------------- Task: TelemetryTask (500 ms) -------------------- */

void TelemetryTask(void *argument)
{
  (void)argument;

  const uint32_t period = ms_to_ticks(500);
  uint32_t next = osKernelGetTickCount();

  app_inputs_t in_snap;
  uint8_t payload[32];

  for (;;)
  {
    next += period;
    osDelayUntil(next);

    osMutexAcquire(g_inMutex, osWaitForever);
    in_snap = g_in;
    osMutexRelease(g_inMutex);

    Telemetry_Build32(&in_snap, payload);
    Telemetry_Send32(payload);
  }
}

/* -------------------- Task: DiagTask (1 s) -------------------- */

void DiagTask(void *argument)
{
  (void)argument;

  const uint32_t period = ms_to_ticks(1000);
  uint32_t next = osKernelGetTickCount();

  for (;;)
  {
    next += period;
    osDelayUntil(next);

    /* Queue metrics */
    uint32_t rx_cnt = osMessageQueueGetCount(canRxQueueHandle);
    uint32_t tx_cnt = osMessageQueueGetCount(canTxQueueHandle);

    /* Heap metrics (FreeRTOS API is available under CMSIS-RTOS v2) */
    size_t free_heap = xPortGetFreeHeapSize();
    size_t min_ever  = xPortGetMinimumEverFreeHeapSize();

    char buf[160];
    (void)snprintf(buf, sizeof(buf),
                   "DIAG: rxQ=%lu txQ=%lu heap=%lu minEver=%lu\r\n",
                   (unsigned long)rx_cnt,
                   (unsigned long)tx_cnt,
                   (unsigned long)free_heap,
                   (unsigned long)min_ever);

    Diag_Log(buf);
  }
}
